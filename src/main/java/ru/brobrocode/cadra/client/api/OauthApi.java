/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.6.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package ru.brobrocode.cadra.client.api;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Generated;
import jakarta.validation.Valid;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import ru.brobrocode.cadra.client.config.CoreFeignConfiguration;
import ru.brobrocode.cadra.client.model.AuthUserToken;
import ru.brobrocode.cadra.client.model.AuthUserTokenAndAppToken;
import ru.brobrocode.cadra.client.model.ErrorsCommonBadAuthorizationBadParameters;
import ru.brobrocode.cadra.client.model.ErrorsCommonBadAuthorizationErrors;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2025-08-17T15:41:09.394389505+05:00[Asia/Yekaterinburg]", comments = "Generator version: 7.6.0")
@Validated
@Tag(name = "Авторизация приложения", description = "Токен приложения необходимо сгенерировать 1 раз. В случае, если токен был скомпрометирован, его нужно запросить еще раз. При этом ранее выданный токен отзывается. Владелец приложения может посмотреть актуальный `access_token` для приложения на сайте [https://dev.hh.ru/admin](https://dev.hh.ru/admin). В случае, если вы еще ни разу [не получали токен приложения](#section/Avtorizaciya/Avtorizaciya-prilozheniya), токен отображаться не будет.  <a name=\"get-client-token\"></a> ### Получение токена приложения Для получения `access_token` необходимо сделать запрос:  ``` POST https://api.hh.ru/token ```  (старый запрос `POST https://hh.ru/oauth/token` считается устаревшим)  В теле запроса необходимо передать [дополнительные параметры](#required_parameters). Тело запроса необходимо передавать в стандартном `application/x-www-form-urlencoded` с указанием соответствующего заголовка `Content-Type`.  Данный `access_token` имеет **неограниченный** срок жизни. При повторном запросе ранее выданный токен отзывается и выдается новый. Запрашивать `access_token` можно не чаще, чем один раз в 5 минут ")
@FeignClient(name = "hh-api", url = "${hh.api.base-url}", configuration = CoreFeignConfiguration.class)
//@FeignClient(name = "hh-api", url = "http://localhost:9000", configuration = CoreFeignConfiguration.class)
public interface OauthApi {

    /**
     * POST /oauth/token : Получение access-токена
     *
     * @param clientId Идентификатор, полученный при [создании приложения](https://dev.hh.ru/admin) (optional)
     * @param clientSecret Защищенный ключ, полученный при [создании приложения](https://dev.hh.ru/admin) (optional)
     * @param code Значение &#x60;authorization_code&#x60;, полученное при [перенаправлении пользователя](#get-authorization_code)  (optional)
     * @param grantType Cпособ запроса токена (optional)
     * @param redirectUri Uri для перенаправления пользователя после авторизации. Если не указать, используется из настроек приложения. При наличии происходит валидация значения. Вероятнее всего, потребуется сделать urlencode значения параметра  (optional)
     * @param refreshToken Refresh-токен, полученный ранее при [получении пары токенов](#section/Avtorizaciya/Obnovlenie-pary-access-i-refresh-tokenov) или прошлом обновлении пары (optional)
     * @return Успешный ответ (status code 200)
     *         or Ошибка параметров запроса (status code 400)
     *         or Действие запрещено (status code 403)
     */
    @Operation(
        operationId = "authorize",
        summary = "Получение access-токена",
        tags = { "Авторизация приложения", "Авторизация работодателя", "Авторизация соискателя" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Успешный ответ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AuthUserTokenAndAppToken.class))
            }),
            @ApiResponse(responseCode = "400", description = "Ошибка параметров запроса", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorsCommonBadAuthorizationBadParameters.class))
            }),
            @ApiResponse(responseCode = "403", description = "Действие запрещено", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorsCommonBadAuthorizationErrors.class))
            })
        },
        security = {
            @SecurityRequirement(name = "OauthToken")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/token",
        produces = { "application/json" },
        consumes = { "application/x-www-form-urlencoded" }
    )
    
    ResponseEntity<AuthUserToken> authorize(
        @Parameter(name = "client_id", description = "Идентификатор, полученный при [создании приложения](https://dev.hh.ru/admin)") @Valid @RequestParam(value = "client_id", required = false) String clientId,
        @Parameter(name = "client_secret", description = "Защищенный ключ, полученный при [создании приложения](https://dev.hh.ru/admin)") @Valid @RequestParam(value = "client_secret", required = false) String clientSecret,
        @Parameter(name = "code", description = "Значение `authorization_code`, полученное при [перенаправлении пользователя](#get-authorization_code) ") @Valid @RequestParam(value = "code", required = false) String code,
        @Parameter(name = "grant_type", description = "Cпособ запроса токена") @Valid @RequestParam(value = "grant_type", required = false) String grantType,
        @Parameter(name = "redirect_uri", description = "Uri для перенаправления пользователя после авторизации. Если не указать, используется из настроек приложения. При наличии происходит валидация значения. Вероятнее всего, потребуется сделать urlencode значения параметра ") @Valid @RequestParam(value = "redirect_uri", required = false) String redirectUri,
        @Parameter(name = "refresh_token", description = "Refresh-токен, полученный ранее при [получении пары токенов](#section/Avtorizaciya/Obnovlenie-pary-access-i-refresh-tokenov) или прошлом обновлении пары") @Valid @RequestParam(value = "refresh_token", required = false) String refreshToken
    );


    /**
     * DELETE /oauth/token : Инвалидация токена
     * Инвалидация работает только на действующем access-токене. После инвалидации токен нельзя будет запросить с помощью refresh-токена - для работы необходимо будет заново авторизоваться в API  Таким образом нельзя инвалидировать токен приложения &lt;a name&#x3D;\&quot;invalidate_token\&quot;&gt;&lt;/a&gt;. В случае компрометации токена необходимо инвалидировать скомпрометированный токен и запросить токен заново! 
     *
     * @return Успешный ответ (status code 204)
     *         or Запрос выполнен не с авторизацией пользователя (status code 403)
     */
    @Operation(
        operationId = "invalidateToken",
        summary = "Инвалидация токена",
        description = "Инвалидация работает только на действующем access-токене. После инвалидации токен нельзя будет запросить с помощью refresh-токена - для работы необходимо будет заново авторизоваться в API  Таким образом нельзя инвалидировать токен приложения <a name=\"invalidate_token\"></a>. В случае компрометации токена необходимо инвалидировать скомпрометированный токен и запросить токен заново! ",
        tags = { "Авторизация работодателя", "Авторизация соискателя", "Авторизация на уровне работодателя" },
        responses = {
            @ApiResponse(responseCode = "204", description = "Успешный ответ"),
            @ApiResponse(responseCode = "403", description = "Запрос выполнен не с авторизацией пользователя", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorsCommonBadAuthorizationErrors.class))
            })
        },
        security = {
            @SecurityRequirement(name = "OauthToken")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/token",
        produces = { "application/json" }
    )
    
    ResponseEntity<Void> invalidateToken(
        
    );



}
